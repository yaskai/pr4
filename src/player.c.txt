#include <math.h>
#include <float.h>
#include <stdio.h>
#include "raylib.h"
#include "raymath.h"
#include "ent.h"
#include "geo.h"
#include "player_gun.h"

#define PLAYER_MAX_PITCH (89.0f * DEG2RAD)
#define PLAYER_SPEED 230.0f
#define PLAYER_MAX_VEL 200.5f

#define PLAYER_MAX_ACCEL 15.5f
float player_accel;
float player_accel_forward;
float player_accel_side;

bool land_frame = false;
float y_vel_prev;

#define PLAYER_FRICTION 11.25f 
#define PLAYER_AIR_FRICTION 9.05f

#define PLAYER_BASE_JUMP_FORCE 280

Vector3 clipY(Vector3 vec) { return Vector3Normalize((Vector3) { vec.x, 0, vec.z }); }

Camera3D *ptr_cam;
InputHandler *ptr_input;
MapSection *ptr_sect;

void PlayerInput(Entity *player, InputHandler *input, float dt);

float cam_bob, cam_tilt;

BoxPoints box_points;

PlayerDebugData *player_debug_data = { 0 };

void cam_Adjust(comp_Transform *ct);

// -----------------------------------------------------------------------------
// ** 
// Player movement functions 
// labeled "pm_<Function>"
typedef struct {
	Vector3 wish_dir;

	Vector3 ground_normal;

	float wish_speed;

	float accel;
	float acc_forward;	
	float acc_side;

	float step;
	float ground;

	u8 block;

} pmInfo;
pmInfo pm_info = {0};

// Main movement loop
void pm_Move(comp_Transform *ct, InputHandler *input, float dt);

// Get look direction
Vector3 pm_GetLookDir(comp_Transform *ct, InputHandler *input); 

// Get (desired!) direction of movement 
Vector3 pm_GetWishMove(comp_Transform *ct, InputHandler *input);

void pm_Accelerate(comp_Transform *ct, float dt);
void pm_Friction(comp_Transform *ct, float dt);

u8 pm_ClipVelocity(Vector3 in, Vector3 normal, Vector3 *out, float bounce);

#define MAX_CLIPS 4
typedef struct {
	Vector3 clips[MAX_CLIPS];	// Clip planes hit 

	Vector3 end_pos; 			// Destination of trace
	Vector3 end_vel;			// Velocity after clip

	Vector3 ground_normal;		// Ground normal at trace end point

	float fraction;				// How much of the requested movement was actually traveled 
	float move_dist;			// How far player moved

	u8 clip_count;				// How many clip planes were hit during trace
	u8 block;					// What blocks movement: GROUND, STEP, WALL, etc.

} pmTraceData;

Vector3 pm_TraceMove(comp_Transform *ct, Vector3 start, MapSection *sect, float dt, pmTraceData *pm, Vector3 vel_in);

// Add velocity, adjust position
void pm_Slide(comp_Transform *ct, MapSection *sect, float dt);
void pm_GroundMove(comp_Transform *ct, u8 block, float dt);

bool pm_CheckGround(comp_Transform *ct, MapSection *sect, float dt, pmTraceData *pm);

void pm_ApplyGravity(comp_Transform *ct, float dt);

Vector3 pm_Step(comp_Transform *ct, Vector3 start, MapSection *sect, float dt);

// **
// -----------------------------------------------------------------------------

void PlayerInit(Camera3D *camera, InputHandler *input, MapSection *test_section, PlayerDebugData *debug_data) {
	ptr_cam = camera;
	ptr_input = input;
	ptr_sect = test_section;

	player_debug_data = debug_data;
}

void PlayerUpdate(Entity *player, float dt) {
	player->comp_transform.bounds = BoxTranslate(player->comp_transform.bounds, player->comp_transform.position);

	/*
	PlayerInput(player, ptr_input, dt);

	y_vel_prev = player->comp_transform.velocity.y;
	land_frame = false;

	// -
	// Apply friction
	float friction = (player->comp_transform.on_ground) ? PLAYER_FRICTION : PLAYER_AIR_FRICTION;

	player->comp_transform.velocity.x += -player->comp_transform.velocity.x * (friction) * dt;
	if(fabsf(player->comp_transform.velocity.x) <= EPSILON) player->comp_transform.velocity.x = 0;

	player->comp_transform.velocity.z += -player->comp_transform.velocity.z * (friction) * dt;
	if(fabsf(player->comp_transform.velocity.z) <= EPSILON) player->comp_transform.velocity.z = 0;

	player->comp_transform.velocity.x = Clamp(player->comp_transform.velocity.x, -PLAYER_MAX_VEL, PLAYER_MAX_VEL);
	player->comp_transform.velocity.z = Clamp(player->comp_transform.velocity.z, -PLAYER_MAX_VEL, PLAYER_MAX_VEL);
	// -

	Vector3 horizontal_velocity = (Vector3) { player->comp_transform.velocity.x, 0, player->comp_transform.velocity.z };
	Vector3 wish_point = Vector3Add(player->comp_transform.position, horizontal_velocity);


	ApplyMovement(&player->comp_transform, wish_point, ptr_sect, &ptr_sect->bvh[1], dt);
	if(player->comp_transform.velocity.y == 0 && y_vel_prev <= -335.0f) {
		land_frame = true;
	}

	ApplyGravity(&player->comp_transform, ptr_sect, &ptr_sect->bvh[1], GRAV_DEFAULT, dt);
	*/

	/*
	PlayerMove(player, dt);
	player->comp_transform.position = Vector3Add(player->comp_transform.position, Vector3Scale(player->comp_transform.velocity, 100 * dt));
	*/

	pm_Move(&player->comp_transform, ptr_input, dt);

	ptr_cam->position = Vector3Add(player->comp_transform.position, Vector3Scale(UP, 0.0f));
	ptr_cam->target = Vector3Add(ptr_cam->position, player->comp_transform.forward);

	if(!player->comp_transform.on_ground) cam_bob = 0;
	ptr_cam->position.y += cam_bob;
	ptr_cam->target.y += cam_bob;

	box_points = BoxGetPoints(player->comp_transform.bounds);
}

void PlayerDraw(Entity *player) {
	//PlayerDisplayDebugInfo(player);
}

/*
void PlayerInput(Entity *player, InputHandler *input, float dt) {
	// Get look direction
	player->comp_transform.forward = pm_GetLookDir(&player->comp_transform, input, dt);

	// Update camera target
	ptr_cam->target = Vector3Add(player->comp_transform.position, player->comp_transform.forward);

	Vector3 right = Vector3CrossProduct(player->comp_transform.forward, UP);

	Vector3 movement = Vector3Zero();
	Vector3 move_forward = movement, move_side = movement;

	if(input->actions[ACTION_MOVE_UP].state == INPUT_ACTION_DOWN)
		move_forward = Vector3Add(move_forward, player->comp_transform.forward);

	if(input->actions[ACTION_MOVE_DOWN].state == INPUT_ACTION_DOWN)	
		move_forward = Vector3Subtract(move_forward, player->comp_transform.forward);

	if(input->actions[ACTION_MOVE_RIGHT].state == INPUT_ACTION_DOWN)
		move_side = Vector3Add(move_side, Vector3Scale(right, 1));

	if(input->actions[ACTION_MOVE_LEFT].state == INPUT_ACTION_DOWN)	
		move_side = Vector3Subtract(move_side, Vector3Scale(right, 1));
	
	move_forward = Vector3Normalize( (Vector3) { move_forward.x, 0, move_forward.z } );
	move_side = Vector3Normalize( (Vector3) { move_side.x, 0, move_side.z } );
	movement = Vector3Normalize(Vector3Add(move_forward, move_side));

	float t = GetTime();

	float len_forward = Vector3Length(move_forward);
	float len_side = Vector3Length(move_side);

	if(len_forward + len_side > 0) {
		player_accel_forward = Clamp(player_accel_forward + (PLAYER_SPEED) * dt, 1.0f, PLAYER_MAX_ACCEL);
		//cam_bob = Lerp(cam_bob, (1.95f + len_forward * 0.75f) * sinf(t * 12 + (len_forward * 0.95f)) + 1.0f, player_accel_forward * dt);
		float bob_targ = (3 * (len_forward + (len_side * 0.5f))) * sinf(t * 12 + (len_forward) * 5.95f) + 1;
		cam_bob = Lerp(cam_bob, bob_targ, 10 * dt);
	} else {
		player_accel_forward = Clamp(player_accel_forward - (PLAYER_FRICTION) * dt, 1.0f, PLAYER_MAX_ACCEL);
		cam_bob = Lerp(cam_bob, 0, 10 * dt);
		if(cam_bob <= EPSILON) cam_bob = 0;
	}

	if(land_frame && player_accel_forward >= PLAYER_MAX_ACCEL * 0.85f)
		cam_bob += (18.5f * y_vel_prev * 0.00125f);

	Vector3 cam_roll_targ = UP;
	if(len_side) {
		player_accel_side = Clamp(player_accel_side + (PLAYER_SPEED) * dt, 0.9f, PLAYER_MAX_ACCEL);

		float side_vel = Vector3DotProduct(movement, right);

		float tilt_max = Clamp(len_side, 0, 0.05f);

		cam_tilt = (side_vel * len_side * player_accel_side);
		cam_tilt = Clamp(cam_tilt, -tilt_max, tilt_max);

		if(fabs(cam_tilt) > EPSILON) cam_roll_targ = Vector3RotateByAxisAngle(UP, player->comp_transform.forward, cam_tilt);
	} else {
		player_accel_side = Clamp(player_accel_side - (PLAYER_FRICTION) * dt, 0.0f, PLAYER_MAX_ACCEL);
	}

	// Slight tilt when player lands on ground
	if(land_frame) 
		cam_roll_targ = Vector3RotateByAxisAngle(ptr_cam->up, player->comp_transform.forward, 35);

	ptr_cam->up = Vector3Lerp(ptr_cam->up, cam_roll_targ, 0.1f);


	Vector3 vel_forward = Vector3Scale(move_forward, (PLAYER_SPEED * player_accel_forward) * dt);
	Vector3 vel_side = Vector3Scale(move_side, (PLAYER_SPEED * player_accel_side) * dt);
	Vector3 horizontal_velocity = Vector3Add(vel_forward, vel_side);

	player->comp_transform.velocity.x += horizontal_velocity.x * dt;
	player->comp_transform.velocity.z += horizontal_velocity.z * dt;

	if(input->actions[ACTION_JUMP].state == INPUT_ACTION_PRESSED) {
		if(player->comp_transform.on_ground && !CheckCeiling(&player->comp_transform, ptr_sect, &ptr_sect->bvh[0])) {
			player->comp_transform.position.y += 0.01f;	
			player->comp_transform.on_ground = 0;
			player->comp_transform.air_time = 1;
			player->comp_transform.velocity.y = PLAYER_BASE_JUMP_FORCE + player_accel_forward * 2.5f;
		}
	}

	if(IsKeyPressed(KEY_R)) {
		player->comp_transform.position = (Vector3) { 0, 40, 0 };
		player->comp_transform.velocity = Vector3Zero();
		player->comp_transform.on_ground = true;
	} 
}
*/

void PlayerDamage(Entity *player, short amount) {
}

void PlayerDie(Entity *player) {
}

void PlayerDisplayDebugInfo(Entity *player) {
	DrawBoundingBox(player->comp_transform.bounds, RED);

	Ray view_ray = (Ray) { .position = ptr_cam->position, .direction = player->comp_transform.forward };	
	player_debug_data->view_dest = Vector3Add(view_ray.position, Vector3Scale(view_ray.direction, FLT_MAX * 0.25f));	

	player_debug_data->view_length = FLT_MAX;

	BvhTraceData tr = TraceDataEmpty();
	BvhTracePointEx(view_ray, ptr_sect, &ptr_sect->bvh[0], 0, &tr);

	if(tr.hit) {
		DrawLine3D(player->comp_transform.position, tr.point, SKYBLUE);
	} else 
		DrawRay(view_ray, SKYBLUE);

	if(tr.hit) {
		Tri *tri = &ptr_sect->bvh[0].tris.arr[tr.tri_id];
		DrawTriangle3D(tri->vertices[0], tri->vertices[1], tri->vertices[2], ColorAlpha(SKYBLUE, 0.25f));
		DrawTriangle3D(tri->vertices[2], tri->vertices[1], tri->vertices[0], ColorAlpha(SKYBLUE, 0.25f));
	}

	// Draw box points
	for(short i = 0; i < 8; i++) {
		DrawSphere(box_points.v[i], 2, RED);
	}

	player_debug_data->accel = player_accel;	
}

void pm_Move(comp_Transform *ct, InputHandler *input, float dt) {
	ct->forward = pm_GetLookDir(ct, input);

	// 1. Get wish movement
	Vector3 wish_move = pm_GetWishMove(ct, input);
	Vector3 wish_dir = Vector3Normalize(wish_move);
	float wish_speed = Vector3Length(wish_move);

	pm_info.wish_dir = wish_dir;
	pm_info.wish_speed = wish_speed;

	// 2. Apply fricion
	pm_Friction(ct, dt);

	// 3. Accelerate
	pm_info.accel += wish_speed;
	pm_Accelerate(ct, dt);

	// 4. Handle jump
	if(ct->on_ground && input->actions[ACTION_JUMP].state == 1) {
		float jump = PLAYER_BASE_JUMP_FORCE;
		ct->velocity.y = jump;
		ct->on_ground = false;
		return;
	}

	//ct->on_ground = pm_CheckGround(ct, ptr_sect, dt);

	// 4. Apply gravity if not grounded
	pm_ApplyGravity(ct, dt);

	// 5. Do movement
	pm_Slide(ct, ptr_sect, dt);
	
	if(IsKeyPressed(KEY_R)) {
		ct->position = (Vector3) { 0, 40, 0 };
		ct->velocity = Vector3Zero();
		ct->on_ground = true;
	}
}

Vector3 pm_GetLookDir(comp_Transform *ct, InputHandler *input) {
	ct->pitch = Clamp(
		ct->pitch - input->mouse_delta.y * input->mouse_sensitivity, -PLAYER_MAX_PITCH, PLAYER_MAX_PITCH);

	ct->yaw += input->mouse_delta.x * input->mouse_sensitivity;

	return (Vector3) {
		.x = cosf(ct->yaw) * cosf(ct->pitch),
		.y = sinf(ct->pitch),
		.z = sinf(ct->yaw) * cosf(ct->pitch)
	};
}

#define PM_SPEED_F 150.0f
#define PM_SPEED_S 145.0f
Vector3 pm_GetWishMove(comp_Transform *ct, InputHandler *input) {
	Vector3 right = Vector3CrossProduct(ct->forward, UP);

	short f_input[2] = {
		(input->actions[ACTION_MOVE_U].state == 1) ? 1 : 0,
		(input->actions[ACTION_MOVE_D].state == 1) ? 1 : 0
	};

	short s_input[2] = {
		(input->actions[ACTION_MOVE_R].state == 1) ? 1 : 0,
		(input->actions[ACTION_MOVE_L].state == 1) ? 1 : 0
	};

	Vector3 f_move = (Vector3) {0};
	f_move = Vector3Add(f_move, Vector3Scale(ct->forward,  f_input[0]));
	f_move = Vector3Add(f_move, Vector3Scale(ct->forward, -f_input[1]));
	f_move = clipY(f_move);

	Vector3 s_move = (Vector3) {0};
	s_move = Vector3Add(s_move, Vector3Scale(right,  s_input[0]));
	s_move = Vector3Add(s_move, Vector3Scale(right, -s_input[1]));
	s_move = clipY(s_move);

	Vector3 sum = Vector3Add(f_move, s_move);

	Vector3 wish = Vector3Scale(Vector3Normalize(sum), PLAYER_SPEED);
	return wish;
}

void pm_Accelerate(comp_Transform *ct, float dt) {
	float curr_speed = Vector3DotProduct(ct->velocity, pm_info.wish_dir);
	float add_speed = pm_info.wish_speed - curr_speed;

	if(add_speed <= 0)
		return;

	float accel_speed = pm_info.accel * dt * pm_info.wish_speed; 
	if(accel_speed > add_speed)
		accel_speed = add_speed;

	ct->velocity = Vector3Add(ct->velocity, Vector3Scale(pm_info.wish_dir, accel_speed));
}

void pm_Friction(comp_Transform *ct, float dt) {
	Vector3 vel = ct->velocity;

	float speed = Vector3LengthSqr(vel);
	if(speed < 1) {
		ct->velocity.x = 0;
		ct->velocity.z = 0;
		return;
	}

	if(!ct->on_ground) {
		//return;
	}

	ct->velocity.x += -(ct->velocity.x * PLAYER_FRICTION * dt);
	ct->velocity.z += -(ct->velocity.z * PLAYER_FRICTION * dt);
}

#define STOP_EPSILON 0.0001f
#define FLOOR_NORMAL_Y 0.7f

#define BLOCK_GROUND	0x01
#define BLOCK_STEP		0x02

u8 pm_ClipVelocity(Vector3 in, Vector3 normal, Vector3 *out, float bounce) {
	u8 blocked = 0;	
	if(normal.y >= FLOOR_NORMAL_Y)  				// Floor
		blocked |= BLOCK_GROUND;		
	else if(fabsf(normal.y) <= 0.01f)	// Wall or step
		blocked |= BLOCK_STEP; 		

	float backoff = Vector3DotProduct(in, normal) * bounce;

	Vector3 change = Vector3Scale(normal, backoff);
	*out = Vector3Subtract(in, change);

	if(fabsf(out->x) < STOP_EPSILON) out->x = 0;
	if(fabsf(out->y) < STOP_EPSILON) out->y = 0;
	if(fabsf(out->z) < STOP_EPSILON) out->z = 0;

	return blocked;
}

#define PM_STEP_Y 16.0f

// ** 
// NOTE:
// Add in velocity argument to trace.
// Needed for pm_Step(), using raw ct and pm_info changes state.
#define MAX_BUMPS 3
Vector3 pm_TraceMove(comp_Transform *ct, Vector3 start, MapSection *sect, float dt, pmTraceData *pm, Vector3 vel_in) {
	Vector3 dest = start;

	u8 block = 0; Vector3 clips[MAX_CLIPS] = {0};	
	short num_clips = 0;

	Vector3 vel = vel_in;

	float t_remain = dt;

	for(short i = 0; i < MAX_BUMPS; i++) {
		if(Vector3Length(vel) <= STOP_EPSILON) 
			break;

		Vector3 move = Vector3Scale(vel, t_remain);
		Ray ray = (Ray) { .position = dest, .direction = Vector3Normalize(move) }; 

		BvhTraceData tr = TraceDataEmpty();
		BvhBoxSweep(ray, sect, &sect->bvh[1], 0, ct->bounds, &tr);

		float fraction = (tr.contact_dist / Vector3Length(move));
		fraction = Clamp(fraction, 0.0f, 1.0f);

		dest = Vector3Add(dest, Vector3Scale(move, fraction));

		pm->fraction = fraction;
		if(fraction >= 1.0f)
			break;	

		if(num_clips + 1 < MAX_CLIPS)
			clips[num_clips++] = tr.normal;			
		else 
			break;
			
		for(short j = 0; j < num_clips; j++) {
			float into = Vector3DotProduct(vel, clips[j]);

			if(into < 0)
				block = pm_ClipVelocity(vel, clips[j], &vel, 1);
		}

		t_remain *= (1 - fraction);
	}

	pm->move_dist = Vector3Distance(start, dest);
	pm->block = block;
	pm->end_vel = vel;

	pm->clip_count = 0;
	for(short i = 0; i < num_clips; i++) {
		pm->clips[pm->clip_count++] = clips[i];

		if(clips[i].y >= FLOOR_NORMAL_Y) {
			pm->ground_normal = clips[i];
		}
	}

	return dest;
}

// Determine destination, move player to destination
void pm_Slide(comp_Transform *ct, MapSection *sect, float dt) {
	pmTraceData pm = {0};
	Vector3 dest = pm_TraceMove(ct, ct->position, sect, dt, &pm, ct->velocity);
	ct->on_ground = (pm.block & BLOCK_GROUND);

	if(ct->on_ground) {
		Vector3 dest_step = pm_Step(ct, ct->position, sect, dt);

		Vector2 curr_xz = (Vector2) { ct->position.x, ct->position.z };
		Vector2 slide_xz = (Vector2) { dest.x, dest.z };
		Vector2 step_xz = (Vector2) { dest_step.x, dest_step.z };

		float slide_dist = Vector2Distance(curr_xz, slide_xz);
		float step_dist = Vector2Distance(curr_xz, step_xz);

		if(step_dist > slide_dist)
			dest = dest_step;
	}

	ct->position = dest;
	ct->velocity = pm.end_vel;

	if(ct->on_ground)
		ct->on_ground = pm_CheckGround(ct, sect, dt, &pm);
}

bool pm_CheckGround(comp_Transform *ct, MapSection *sect, float dt, pmTraceData *pm) {
	/*
	Ray ray = (Ray) { .position = ct->position, .direction = DOWN };

	BvhTraceData tr = TraceDataEmpty();
	BvhBoxSweep(ray, sect, &sect->bvh[1], 0, ct->bounds, &tr);

	if(!tr.hit) 
		return false;

	if(tr.normal.y < FLOOR_NORMAL_Y)
		return false;

	if(tr.distance > BODY_VOLUME_MEDIUM.y)
		return false;

	pm_info.ground_normal = tr.normal;
	*/

	for(short i = 0; i < pm->clip_count; i++) {
		if(pm->clips[i].y >= FLOOR_NORMAL_Y) {
			pm_info.ground_normal = pm->clips[i];
			return true;
		}
	}

	return false;
}

#define GROUND_EPSILON 0.1f
void pm_ApplyGravity(comp_Transform *ct, float dt) {
	float grav = (GRAV_DEFAULT * 1.25f) * dt;
	ct->velocity.y -= grav;

	if(ct->on_ground) {
		/*
		if(fabsf(ct->position.y - pm_info.ground) <= GROUND_EPSILON) {
			if(ct->position.y < pm_info.ground)
				ct->velocity.y += grav + (GROUND_EPSILON * dt);
		}
		*/
		
		pm_ClipVelocity(ct->velocity, pm_info.ground_normal, &ct->velocity, 1.0001f);
	}
}

// Return traced stepped position 
Vector3 pm_Step(comp_Transform *ct, Vector3 start, MapSection *sect, float dt) {
	// Start from step up
	Vector3 step_up = start;
	step_up.y += PM_STEP_Y;

	// Trace upwards by velocity
	pmTraceData pm_up;
	Vector3 up_end = pm_TraceMove(ct, step_up, sect, dt, &pm_up, ct->velocity);

	// Adjust, step down
	Vector3 step_down = up_end;
	step_down.y = step_up.y - PM_STEP_Y;

	Vector3 down_vel = (Vector3) { 0, pm_up.end_vel.y - PM_STEP_Y, 0 };
	down_vel = Vector3Scale(down_vel, dt);

	// Trace downwards by velocity 
	pmTraceData pm_down;
	Vector3 step_end = pm_TraceMove(ct, step_down, sect, dt, &pm_down, down_vel);

	return step_end;
}

